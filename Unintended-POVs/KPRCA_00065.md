## Post Event Analysis
Post event analysis identified an additional vulnerability, as described below.

The author describes a heart-bleed type bug that leaks information through an over-read.  CRS-generated POVs did not exploit that vulnerability, rather, they use a stack buffer overflow, which is not mitigated by the reference patch for the service.

##Reference POV##
* Magic page address 4347c60b accessed at instruction 804b2dd in memcpy, called by 08048296 \_otp\_populate+0x46
* memcpy called to copy 0xa49 bytes into baaa9f40 from 4347c5b7

After that, memcpy called to move 1f40 bytes from baaa8f96 to b7e000b9

    Address  Function
    -------  --------
    0804B2E6 memcpy+0x46
    0804899D otp_extend_session+0x11D
    08048166 main+0xC6
    0804D2DA _start

    Secret transmitted in write of 1f41 bytes from b7e000b8.
    fwrite called from 080489D3 otp_extend_session+0x153

Vulnerability in "overread" in second call to memcpy.

##Disekt vs ForAllSecure, round 32, throw 1##
Return address for otp\_verify\_otp (804e7fc) is overwritten, leads to execution from stack.

    added backtrack START:0x8048e02:ret track addr: 0xbaaaafa8, value 0xbaaaaf14 : 13fc3aaf
    added backtrack:0x804b2e6:mov byte ptr [ecx+eax],dl : 13fc39ed
    added backtrack:0x804b2dd:mov dl,byte ptr [ecx+eax] : 13fc39ea
    added backtrack:0x804d333: follows kernel write of 0xbaaaaf14 to 0x804e7fc : 13fc2269

The receive of the corrupt return pointer value is a receive length of 0x400 bytes into buffer starting at 804e760

         Address  Function
         -------  --------
         0804D333 receive+0x1B
         0804965E fread+0x3E
         08048EB0 read_n+0x40
         080480FF sub_80480A0
         0804D2DF _start+0x5

-- and contrary to Ida's stack trace,
it is called from _refil 8049807, which is called from the fread per the stack trace.
The corrupt return pointer value is memcpy'd from fread:

           0804B2E6 memcpy+0x46
           080496B7 fread+0x97

as part of a 0x90 byte copy.

The unintended bug appears to be in fread, in which it is possible to cause
memcpy to overwrite a buffer used to read from a simulated file.  This leads to
corruption of the opt\_verify\_opt return pointer.

Other POVs generated by other CRS's appear the same, except for one described below.

##ForAllSecure vs Disekt, round 33, throw 6##
In round 28, a Disekt RCB came online that foiled all POVs for several rounds.
The RCB uses control flow guards to protect the return from functions, 
including opt\_verify\_opt.  As is shown below, the Disekt RCB
ensured their service did not lose control of returns from protected functions.  However,
these guards did not protect against corruption of EBP, and this led to control flow
corruption.

In round 33, ForAllSecure scored against this RCB (with 1 out of 10 throws), and in round
34 they also scored, (with 2 out of 10 throws).  ForAllSecure threw the very
same POV in the previous round, but it did not land.

In the rare cases when it succeeds, this POV, causes the memcpy function to overwrite its
own return address.  At the time of the call to memcpy the call stack frame is nonsense:
    
    Address  Function              
    -------  --------              
    08049480 fread+0x85            
    08048DE7 otp_generate_otp+0x707
    0804816F main+0x5F             
    080491E6 fflush+0xA8           
  
The actual call chain is:

    fread 
    read_n
    main

At this point, EBP is corrupt, so a local address parameter, (e.g., EBP-8),   
passed by main to read\_n is no longer what is intended, rather, it is the address of what
will become a return address from memcpy, leading to control of execution 
by the POV.  Evidence of a corrupt EPB:

    In main, the first call to read\_n, EBP was 0xBAAAAF98.
    The next call to read\_n from the same instruction in main, ebp is 0xBAAAAEE8.

The corruption of EBP occurs sometime between those two calls to read\_n from main. 
A different call to fread, from opt\_verify\_opt, causes the same fread buffer 
overflow that was exploited by the other POVs, leading to an overwrite of the 
stack frame, including the return address from opt\_verify\_opt.  
The Disekt RCB hardcodes the return from opt\_verify\_opt to someplace in
main, (though not from where it was called), and thus control flow has not yet
been corrupted by the overwrite.  However, the "pop ebp" just prior to the
faux "return" is not protected, and thus EBP is controlled by the POV.

 
